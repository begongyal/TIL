SSL 인증서
참고:
https://m.blog.naver.com/alice_k106/221468341565

인증서란?

=> '나는 신뢰해도 되는 사람입니다.' 를 증명하기 위한 서류. 주로 웹 브라우저(클라이언트)와 웹 서버(서버) 사이에서 클라이언트가 접속하려는 웹 서버가 믿을만한 지를 판단하기 위해 쓰인다.

인증서의 동작원리
0. 인증서의 내용물(정확하지 않음. 다른 정보가 더 있을 수도 있다.)
(1) 인증서의 소유자 이름, 
(2) 인증서 소유자의 공개 키 (당연히 비밀 키는 소유자가 가지고 있다), 
(3) 인증서의 유효 기간
(4) 고유한 UID
(5) 1-4번을 해싱한 값(해싱 기법은 알려져있으나, 해싱 기법이 인증서 자체에 포함되어있는지 어쩐지는 모르겠음. 그리고 사실 5번 자체가 인증서에 매번 포함이 되어있는지도 모르겠음. 그냥 그때그때 1~4번을 해시하면 되는데.)
(6) 5번을 Private Key로 암호화한 값(여기서 Private Key는, Root CA의 인증서인 경우에는 Root CA의 Private Key이고, 하위 계층(ex. Intermediate CA 등)의 인증서인 경우에는 그 인증서를 인증 및 발급해준 상위 기관의 Private Key이다.

참고로, 6번에서 Private Key로 인증서의 내용을 암호화할 때, 5번 처럼 해싱을 하고 암호화하는 이유는, 해싱은 원문 길이가 어떻든 간에 일정한 길이의 문자열로 바꿔주기 때문에, Private Key로 암호화 하는 과정이 효율적이게 바뀌기 때문이다.
그리고 Private Key로 암호화를 해야되는 이유는 아래서 자세히 설명한다.


1. 신뢰 가능한 기관(Root CA)
=> 최상위 인증 기관으로, 모든 사람들이 믿을만 하다고 간주하는 기관이다.
Root CA는 Private Key를 가지고 있고, 모든 사람들은 Root CA를 믿기 때문에 Public Key를 웹 브라우저 안에 가지고 있다.
어떤 정보가 암호화가 되어있는데, 만약에 이 정보가 누구나 가지고 있는, Root CA의 Public Key로 복호화가 된다면
이 정보는 Root CA가 가진 Private Key로 암호화되었다는 것을 의미하기 때문에, 해당 정보를 믿을 수 있다.

2. Intermediate CA(ICA)
=> Root CA로부터 직접 인증서를 발급받은 기관이다.
ICA는 우선 자신들의 인증서를 1-4를 먼저 만들고, 그 내용으로 5번까지 만든다. 그리고 Root CA에게 5번(hashed value)를 가져가서 Root CA의 Private Key로 암호화 해줄수있냐고 요청한다. Root CA는 ICA를 믿을 수 있는 기관이라고 판단하면, 암호화 해준다.
이 과정까지 끝나면 ICA는 Root CA로부터 믿을만하다고 인증되었다. 일반 클라이언트는 ICA의 인증서가 믿을만한지를 판단하기 위해서, 다음과 같은 과정을 거친다.
A. 먼저, ICA 인증서의 6번 값을 Root CA의 Public Key로 복호화함으로써 6번 값이 Root CA로부터 암호화되었다는 것을 알 수 있게 된다(그리고 이는 Root CA가 ICA를 인증했으므로 우리도 ICA를 믿을 수 있게 된다는 뜻이다).
B. 그 값을, 1~4번 데이터를 해시한 값과 비교해서 그 인증서의 데이터가 변조되지 않았음을 알 수 있게 된다.

3. 제 3의 CA
ICA가 Root CA로부터 인증받았던 것처럼, 제 3의 CA는 ICA로부터 인증받는다.
제 3의 CA도 자신들의 인증서를 만들고(1~4번) ICA에게 가서 ICA의 Private Key로 그 인증서를 해시한 값(5번)을 암호화해달라고 요청한다. 그러면 클라이언트는 ICA를 믿을 수 있으므로 ICA의 Public Key를 사용해서 제 3의 CA의 인증서를 복호화 하게 된다. 이를 Chain of Trust라 하여 최상위 인증 기관으로부터 하위 기관까지 모두 믿을 수 있게 된다.


그렇다면 왜 Root CA가 ICA뿐만 아니라 모든 CA를 다 인증해주지 않고 중간에 ICA를 두게 되었을까?
=> 만약 Root CA의 Private Key가 유출되면, 어떤 인증서가 정말로 Root CA로부터 암호화 된 건지를 판단할 수 없게 된다.
ICA를 두면, 설령 Root CA의 Private Key가 유출되더라도, ICA의 Private Key가 유출되지 않는 한, ICA로부터 인증받은 인증서들은 믿을 수가 있다. (조건: ICA는 Root CA의 Private Key가 유출되기 전에 이미 인증받았던 기관이어야 함.) 중간 다리가 생기는 꼴이다.
"그리고 실제로 ICA들의 Public Key도 웹 브라우저 안에 포함되어 있다."




HTTPS 작동 방식
참고: https://opentutorials.org/course/228/4894

1. 클라이언트가 웹 사이트에 접속을 요청할 때, 다음과 같은 정보를 같이 보낸다. (Client Hello)
A. 클라이언트가 생성한 Nonce라고 하는 난수 값(timestamp를 포함. 왜 timestamp를 포함하는지는 모르겠음)
B. 클라이언트가 지원하는 암호화 방식(대칭키를 만들기 위해서?인지 후에 나오는 PMS를 MS로 만들기 위한 방식인지 어쩐지는 모르겠음)
C. 세션 아이디(세션아이디가 있다면 보낸다. 다만 지금은 처음 요청하는 단계라서 세션 아이디가 없다.)

2. 서버는 클라이언트에 대한 응답으로 다음과 같은 정보를 보낸다. (Server Hello)
A. 서버에서 생성한 Nonce라고 하는 난수 값
B. Client Hello에서 클라이언트가 사용할 수 있다고 말했던 암호화 방식 중에 서버도 사용할 수 있는 방식 1개.
C. SSL 인증서

3. 클라이언트는 서버가 보낸 SSL 인증서가 신뢰할 수 있는 인증서인지에 대해 검증한다. (이 인증서에 포함된 암호화된 hashed value가, 클라이언트의 웹브라우저가 포함하고 있는 public key들 중의 하나로 열리는지를 검증한다.) 그리고 서로가 서로에게 보낸 두 가지 Nonce값들을 사용해서 PMS(pre master secret) 라는 값을 만들어낸다. 아직까지는 암호화되지 않은 상태로 Nonce값들이 주고받아졌고, 이제 PMS는 서버의 SSL 인증서 안에 들어있는 Public Key를 사용해서 암호화 한 뒤, 서버에 보낸다.

4. 서버는 자신의 Private Key로, 암호화된 PMS를 복호화 한다. 이로써 클라이언트와 서버 모두 안전하게 PMS를 가지고 있게 된다. 그러면 양측 다 PMS를 통해서 master secret이라는 값을 만들어내고, 이 master secret으로 session key를 생성한다. 이 session key(대칭키)를 이용해서 서로 암호화된 데이터를 주고받을 수 있게 된다.

5. 암호화 연결이 처음으로 성립되었을 때, integrity check를 한다. (이 내용은 잘 모르겠고 참고 링크만 걸어둠)
참고: https://www.tuwlab.com/ece/26967
